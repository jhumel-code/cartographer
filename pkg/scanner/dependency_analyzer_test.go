package scanner

import (
	"context"
	"fmt"
	"os"
	"path/filepath"
	"testing"

	"github.com/ianjhumelbautista/cartographer/pkg/artifact"
)

// Test constants to avoid duplication
const (
	// File names
	cargoTomlFile       = "Cargo.toml"
	cargoLockFile       = "Cargo.lock"
	packageJsonFile     = "package.json"
	packageLockFile     = "package-lock.json"
	yarnLockFile        = "yarn.lock"
	goModFile           = "go.mod"
	goSumFile           = "go.sum"
	pomXmlFile          = "pom.xml"
	buildGradleFile     = "build.gradle"
	requirementsTxtFile = "requirements.txt"
	pipfileFile         = "Pipfile"
	gemfileFile         = "Gemfile"
	gemfileLockFile     = "Gemfile.lock"
	composerJsonFile    = "composer.json"
	composerLockFile    = "composer.lock"
	pubspecYamlFile     = "pubspec.yaml"
	pubspecLockFile     = "pubspec.lock"
	packagesConfigFile  = "packages.config"
	packageSwiftFile    = "Package.swift"
	packageResolvedFile = "Package.resolved"
	conanfileTxtFile    = "conanfile.txt"
	conanfilePyFile     = "conanfile.py"
	mixExsFile          = "mix.exs"
	stackYamlFile       = "stack.yaml"
	terraformFile       = "main.tf"

	// Error messages
	scanErrorMsg          = "Scan() error = %v"
	scanErrorNilMsg       = "Scan() error = %v, expected nil"
	expectedDependencyMsg = "Expected to find dependency '%s'"
	expectedVersionMsg    = "Expected version '%s' for '%s', got '%s'"
	expectedDepTypeMsg    = "Expected dependency_type '%s' for '%s', got '%s'"
	cargoTomlContent      = `[package]
name = "test-package"
version = "0.1.0"

[dependencies]
serde = "1.0"
tokio = { version = "1.0", features = ["full"] }
clap = "3.0"

[dev-dependencies]
criterion = "0.3"`

	cargoLockContent = `# This file is automatically @generated by Cargo.
# It is not intended for manual editing.
version = 3

[[package]]
name = "serde"
version = "1.0.136"
source = "registry+https://github.com/rust-lang/crates.io-index"

[[package]]
name = "tokio"
version = "1.17.0"
source = "registry+https://github.com/rust-lang/crates.io-index"`

	packageJsonContent = `{
  "name": "test-app",
  "version": "1.0.0",
  "dependencies": {
    "express": "^4.18.0",
    "lodash": "^4.17.21"
  },
  "devDependencies": {
    "jest": "^27.0.0",
    "eslint": "^8.0.0"
  }
}`

	packageLockJsonContent = `{
  "name": "test-app",
  "version": "1.0.0",
  "dependencies": {
    "express": {
      "version": "4.18.2"
    },
    "lodash": {
      "version": "4.17.21"
    }
  }
}`

	yarnLockContent = `# yarn lockfile v1

"express@^4.18.0":
  version "4.18.2"
  resolved "https://registry.yarnpkg.com/express/-/express-4.18.2.tgz"

"lodash@^4.17.21":
  version "4.17.21"
  resolved "https://registry.yarnpkg.com/lodash/-/lodash-4.17.21.tgz"`

	goModContent = `module example.com/test

go 1.19

require (
	github.com/gorilla/mux v1.8.0
	github.com/stretchr/testify v1.8.0
)

require (
	github.com/davecgh/go-spew v1.1.1 // indirect
)`

	goSumContent = `github.com/gorilla/mux v1.8.0 h1:i40aqfkR1h2SlN9hojwV5ZA91wcXFOvTdnTDhBKtgYw=
github.com/gorilla/mux v1.8.0/go.mod h1:DVbg23sWSpFRCP0SfiEN6jmj59UnW/n46BH5rLB71So=
github.com/stretchr/testify v1.8.0 h1:pSgiaMZlXftHpm5L7V1+rVB+AZJydKsMxsQBIJw4PKk=
github.com/stretchr/testify v1.8.0/go.mod h1:yNjHg4UonilssWZ8iaSj1OCr/vHnekPRkoO+kdMU+MU=`

	pomXmlContent = `<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0">
    <modelVersion>4.0.0</modelVersion>
    <groupId>com.example</groupId>
    <artifactId>test-app</artifactId>
    <version>1.0.0</version>
    
    <dependencies>
        <dependency>
            <groupId>org.springframework</groupId>
            <artifactId>spring-core</artifactId>
            <version>5.3.21</version>
        </dependency>
        <dependency>
            <groupId>junit</groupId>
            <artifactId>junit</artifactId>
            <version>4.13.2</version>
            <scope>test</scope>
        </dependency>
    </dependencies>
</project>`

	buildGradleContent = `plugins {
    id 'java'
}

dependencies {
    implementation 'org.springframework:spring-core:5.3.21'
    implementation 'com.google.guava:guava:31.1-jre'
    testImplementation 'junit:junit:4.13.2'
    testImplementation 'org.mockito:mockito-core:4.6.1'
}`

	requirementsTxtContent = `Django>=4.0.0,<5.0.0
requests==2.28.1
pytest>=7.0.0
flask~=2.1.0
# This is a comment
numpy==1.23.1`

	pipfileContent = `[packages]
django = ">=4.0.0,<5.0.0"
requests = "==2.28.1"
flask = "~=2.1.0"

[dev-packages]
pytest = ">=7.0.0"
black = "*"`

	gemfileContent = `source 'https://rubygems.org'

gem 'rails', '~> 7.0.0'
gem 'pg', '~> 1.1'
gem 'puma', '~> 5.0'

group :development, :test do
  gem 'rspec-rails', '~> 5.0'
  gem 'factory_bot_rails', '~> 6.2'
end`

	gemfileLockContent = `GEM
  remote: https://rubygems.org/
  specs:
    rails (7.0.4)
      actioncable (= 7.0.4)
      actionmailbox (= 7.0.4)
    pg (1.4.3)
    puma (5.6.4)
      nio4r (~> 2.0)
    rspec-rails (5.1.2)
      actionpack (>= 5.2)
      activesupport (>= 5.2)`

	composerJsonContent = `{
  "name": "example/test-app",
  "require": {
    "php": "^8.1",
    "symfony/framework-bundle": "^6.1",
    "doctrine/orm": "^2.12"
  },
  "require-dev": {
    "phpunit/phpunit": "^9.5",
    "symfony/maker-bundle": "^1.43"
  }
}`

	composerLockContent = `{
  "packages": [
    {
      "name": "symfony/framework-bundle",
      "version": "v6.1.3"
    },
    {
      "name": "doctrine/orm",
      "version": "2.12.4"
    }
  ],
  "packages-dev": [
    {
      "name": "phpunit/phpunit",
      "version": "9.5.21"
    }
  ]
}`

	pubspecYamlContent = `name: test_app
description: A new Flutter project.
version: 1.0.0+1

dependencies:
  flutter:
    sdk: flutter
  http: ^0.13.5
  provider: ^6.0.3

dev_dependencies:
  flutter_test:
    sdk: flutter
  flutter_lints: ^2.0.0`

	pubspecLockContent = `packages:
  http:
    dependency: "direct main"
    description:
      name: http
      url: "https://pub.dartlang.org"
    source: hosted
    version: "0.13.5"
  provider:
    dependency: "direct main"
    description:
      name: provider
      url: "https://pub.dartlang.org"
    source: hosted
    version: "6.0.3"`

	packagesConfigContent = `<?xml version="1.0" encoding="utf-8"?>
<packages>
  <package id="Newtonsoft.Json" version="13.0.1" targetFramework="net472" />
  <package id="Microsoft.Extensions.DependencyInjection" version="6.0.0" targetFramework="net472" />
</packages>`

	packageSwiftContent = `// swift-tools-version:5.6
import PackageDescription

let package = Package(
    name: "TestPackage",
    dependencies: [
        .package(url: "https://github.com/Alamofire/Alamofire.git", from: "5.6.0"),
        .package(url: "https://github.com/Quick/Quick.git", from: "5.0.0"),
    ]
)`

	packageResolvedContent = `{
  "pins": [
    {
      "package": "Alamofire",
      "repositoryURL": "https://github.com/Alamofire/Alamofire.git",
      "state": {
        "revision": "bc268c28fb170f494de9e9927c371b8342979ece",
        "version": "5.6.2"
      }
    },
    {
      "package": "Quick",
      "repositoryURL": "https://github.com/Quick/Quick.git",
      "state": {
        "revision": "f9d519828bb03dfc8125467d8f7b93131951124c",
        "version": "5.0.1"
      }
    }
  ]
}`

	conanfileTxtContent = `[requires]
boost/1.79.0
poco/1.12.2@conan/stable

[generators]
cmake`

	conanfilePyContent = `from conan import ConanFile

class TestConan(ConanFile):
    requires = "boost/1.79.0", "poco/1.12.2@conan/stable"`

	mixExsContent = `defmodule TestApp.MixProject do
  use Mix.Project

  def project do
    [
      app: :test_app,
      version: "0.1.0",
      deps: deps()
    ]
  end

  defp deps do
    [
      {:phoenix, "~> 1.6.15"},
      {:ecto_sql, "~> 3.6"},
      {:postgrex, ">= 0.0.0"},
      {:ex_doc, "~> 0.27", only: :dev, runtime: false}
    ]
  end
end`

	stackYamlContent = `resolver: lts-19.14

packages:
- .

extra-deps:
- aeson-2.1.0.0
- vector-0.13.0.0

ghc-options:
  "$everything": -Wall`

	terraformContent = `terraform {
  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = "~> 4.16"
    }
  }
}

module "vpc" {
  source  = "terraform-aws-modules/vpc/aws"
  version = "~> 3.14.0"
}

module "security_group" {
  source = "terraform-aws-modules/security-group/aws"
  version = "~> 4.9.0"
}`
)

// Helper function to create test files for testing.TB interface
func createTestFileGeneric(tb testing.TB, dir, name, content string) string {
	path := filepath.Join(dir, name)

	// Create subdirectories if needed
	if subdir := filepath.Dir(path); subdir != dir {
		if err := os.MkdirAll(subdir, 0755); err != nil {
			tb.Fatalf("Failed to create directory %s: %v", subdir, err)
		}
	}

	if err := os.WriteFile(path, []byte(content), 0644); err != nil {
		tb.Fatalf("Failed to create test file %s: %v", path, err)
	}

	return path
}

func TestNewDependencyAnalyzer(t *testing.T) {
	analyzer := NewDependencyAnalyzer()
	if analyzer == nil {
		t.Error("NewDependencyAnalyzer() returned nil")
	}
}

func TestDependencyAnalyzerName(t *testing.T) {
	analyzer := NewDependencyAnalyzer()
	name := analyzer.Name()
	if name != "dependency-analyzer" {
		t.Errorf("Expected name 'dependency-analyzer', got '%s'", name)
	}
}

func TestDependencyAnalyzerSupportedTypes(t *testing.T) {
	analyzer := NewDependencyAnalyzer()
	types := analyzer.SupportedTypes()

	expectedTypes := []artifact.Type{
		// Linux Distribution Package Managers
		artifact.TypeDebianPackage,
		artifact.TypeRPMPackage,
		artifact.TypeAlpinePackage,
		artifact.TypeArchPackage,
		artifact.TypeGentooPackage,
		artifact.TypeSnapPackage,
		artifact.TypeFlatpakPackage,
		artifact.TypeAppImagePackage,
		// Language Package Managers
		artifact.TypeNpmPackage,
		artifact.TypePythonPackage,
		artifact.TypeGoModule,
		artifact.TypeRustCrate,
		artifact.TypeRubyGem,
		artifact.TypePHPPackage,
		artifact.TypeMavenPackage,
		artifact.TypeGradlePackage,
		artifact.TypeDotNetPackage,
		artifact.TypeSwiftPackage,
		artifact.TypeDartPackage,
		artifact.TypeCocoaPod,
		artifact.TypeConanPackage,
		artifact.TypeCRANPackage,
		artifact.TypeHexPackage,
		artifact.TypeHaskellPackage,
		artifact.TypeTerraformConfig,
	}

	if len(types) != len(expectedTypes) {
		t.Errorf("Expected %d supported types, got %d", len(expectedTypes), len(types))
	}

	// Create a map for easier checking
	typeMap := make(map[artifact.Type]bool)
	for _, t := range types {
		typeMap[t] = true
	}

	for _, expectedType := range expectedTypes {
		if !typeMap[expectedType] {
			t.Errorf("Expected type %v not found in supported types", expectedType)
		}
	}
}

func TestDependencyAnalyzerScan(t *testing.T) {
	analyzer := NewDependencyAnalyzer()
	tempDir := t.TempDir()

	// Create test files for different package managers
	createTestFileGeneric(t, tempDir, cargoTomlFile, cargoTomlContent)
	createTestFileGeneric(t, tempDir, packageJsonFile, packageJsonContent)
	createTestFileGeneric(t, tempDir, goModFile, goModContent)
	createTestFileGeneric(t, tempDir, pomXmlFile, pomXmlContent)
	createTestFileGeneric(t, tempDir, requirementsTxtFile, requirementsTxtContent)
	createTestFileGeneric(t, tempDir, gemfileFile, gemfileContent)
	createTestFileGeneric(t, tempDir, composerJsonFile, composerJsonContent)
	createTestFileGeneric(t, tempDir, pubspecYamlFile, pubspecYamlContent)
	createTestFileGeneric(t, tempDir, packagesConfigFile, packagesConfigContent)
	createTestFileGeneric(t, tempDir, packageSwiftFile, packageSwiftContent)
	createTestFileGeneric(t, tempDir, conanfileTxtFile, conanfileTxtContent)
	createTestFileGeneric(t, tempDir, mixExsFile, mixExsContent)
	createTestFileGeneric(t, tempDir, terraformFile, terraformContent)

	source := artifact.Source{
		Type:     artifact.SourceTypeFilesystem,
		Location: tempDir,
	}

	ctx := context.Background()
	artifacts, err := analyzer.Scan(ctx, source)

	if err != nil {
		t.Errorf("Scan() error = %v, want nil", err)
		return
	}

	if len(artifacts) == 0 {
		t.Error("Expected artifacts to be found, got none")
		return
	}

	// Check that we found dependencies from different package managers (only implemented ones)
	foundTypes := make(map[artifact.Type]int)
	for _, art := range artifacts {
		foundTypes[art.Type]++
	}

	expectedMinTypes := map[artifact.Type]int{
		artifact.TypeRustCrate:    2, // At least 2 Cargo dependencies (implemented)
		artifact.TypeNpmPackage:   2, // At least 2 NPM dependencies (implemented)
		artifact.TypeGoModule:     2, // At least 2 Go modules (implemented)
		artifact.TypeMavenPackage: 2, // At least 2 Maven dependencies (implemented)
		artifact.TypePHPPackage:   2, // At least 2 PHP packages (implemented)
		// Only test implemented parsers to start with
	}

	for expectedType, minCount := range expectedMinTypes {
		if count, found := foundTypes[expectedType]; !found || count < minCount {
			t.Errorf("Expected at least %d artifacts of type %v, got %d", minCount, expectedType, count)
		}
	}
}

// Test Cargo (Rust) parsing
func TestDependencyAnalyzerCargoToml(t *testing.T) {
	analyzer := NewDependencyAnalyzer()
	tempDir := t.TempDir()

	createTestFileGeneric(t, tempDir, cargoTomlFile, cargoTomlContent)

	source := artifact.Source{
		Type:     artifact.SourceTypeFilesystem,
		Location: tempDir,
	}

	ctx := context.Background()
	artifacts, err := analyzer.Scan(ctx, source)

	if err != nil {
		t.Errorf("Scan() error = %v", err)
		return
	}

	// Should find serde, tokio, clap from dependencies and criterion from dev-dependencies
	expectedDeps := map[string]string{
		"serde":     "1.0",
		"tokio":     "", // Complex dependency format
		"clap":      "3.0",
		"criterion": "0.3",
	}

	foundDeps := make(map[string]string)
	for _, art := range artifacts {
		if art.Type == artifact.TypeRustCrate {
			foundDeps[art.Name] = art.Version

			// Check metadata
			if art.Metadata["package_manager"] != "cargo" {
				t.Errorf("Expected package_manager to be 'cargo', got '%s'", art.Metadata["package_manager"])
			}
			if art.Metadata["source_file"] != "Cargo.toml" {
				t.Errorf("Expected source_file to be 'Cargo.toml', got '%s'", art.Metadata["source_file"])
			}
		}
	}

	for name, expectedVersion := range expectedDeps {
		if foundVersion, found := foundDeps[name]; !found {
			t.Errorf("Expected to find dependency '%s'", name)
		} else if expectedVersion != "" && foundVersion != expectedVersion {
			t.Errorf("Expected version '%s' for '%s', got '%s'", expectedVersion, name, foundVersion)
		}
	}
}

func TestDependencyAnalyzerCargoLock(t *testing.T) {
	analyzer := NewDependencyAnalyzer()
	tempDir := t.TempDir()

	createTestFileGeneric(t, tempDir, cargoLockFile, cargoLockContent)

	source := artifact.Source{
		Type:     artifact.SourceTypeFilesystem,
		Location: tempDir,
	}

	ctx := context.Background()
	artifacts, err := analyzer.Scan(ctx, source)

	if err != nil {
		t.Errorf("Scan() error = %v", err)
		return
	}

	expectedDeps := map[string]string{
		"serde": "1.0.136",
		"tokio": "1.17.0",
	}

	foundDeps := make(map[string]string)
	for _, art := range artifacts {
		if art.Type == artifact.TypeRustCrate {
			foundDeps[art.Name] = art.Version

			// Check metadata for resolved dependencies
			if art.Metadata["resolved"] != "true" {
				t.Errorf("Expected resolved to be 'true' for Cargo.lock dependencies")
			}
		}
	}

	for name, expectedVersion := range expectedDeps {
		if foundVersion, found := foundDeps[name]; !found {
			t.Errorf("Expected to find dependency '%s'", name)
		} else if foundVersion != expectedVersion {
			t.Errorf("Expected version '%s' for '%s', got '%s'", expectedVersion, name, foundVersion)
		}
	}
}

// Test NPM (Node.js) parsing
func TestDependencyAnalyzerPackageJson(t *testing.T) {
	analyzer := NewDependencyAnalyzer()
	tempDir := t.TempDir()

	createTestFileGeneric(t, tempDir, packageJsonFile, packageJsonContent)

	source := artifact.Source{
		Type:     artifact.SourceTypeFilesystem,
		Location: tempDir,
	}

	ctx := context.Background()
	artifacts, err := analyzer.Scan(ctx, source)

	if err != nil {
		t.Errorf("Scan() error = %v", err)
		return
	}

	expectedDeps := map[string]struct {
		version string
		depType string
	}{
		"express": {"^4.18.0", "production"},
		"lodash":  {"^4.17.21", "production"},
		"jest":    {"^27.0.0", "development"},
		"eslint":  {"^8.0.0", "development"},
	}

	foundDeps := make(map[string]struct {
		version string
		depType string
	})

	for _, art := range artifacts {
		if art.Type == artifact.TypeNpmPackage {
			foundDeps[art.Name] = struct {
				version string
				depType string
			}{art.Version, art.Metadata["dependency_type"]}
		}
	}

	for name, expected := range expectedDeps {
		if found, exists := foundDeps[name]; !exists {
			t.Errorf("Expected to find dependency '%s'", name)
		} else {
			if found.version != expected.version {
				t.Errorf("Expected version '%s' for '%s', got '%s'", expected.version, name, found.version)
			}
			if found.depType != expected.depType {
				t.Errorf("Expected dependency_type '%s' for '%s', got '%s'", expected.depType, name, found.depType)
			}
		}
	}
}

// Test additional NPM files
func TestDependencyAnalyzerPackageLockJson(t *testing.T) {
	analyzer := NewDependencyAnalyzer()
	tempDir := t.TempDir()

	createTestFileGeneric(t, tempDir, packageLockFile, packageLockJsonContent)

	source := artifact.Source{
		Type:     artifact.SourceTypeFilesystem,
		Location: tempDir,
	}

	ctx := context.Background()
	artifacts, err := analyzer.Scan(ctx, source)

	if err != nil {
		t.Errorf("Scan() error = %v", err)
		return
	}

	// Check if any NPM artifacts are found (depends on implementation)
	foundNpmArtifacts := false
	for _, art := range artifacts {
		if art.Type == artifact.TypeNpmPackage {
			foundNpmArtifacts = true
			break
		}
	}

	// Note: Not all implementations may parse package-lock.json
	if !foundNpmArtifacts {
		t.Log("No NPM artifacts found from package-lock.json (may not be implemented)")
	}
}

func TestDependencyAnalyzerYarnLock(t *testing.T) {
	analyzer := NewDependencyAnalyzer()
	tempDir := t.TempDir()

	createTestFileGeneric(t, tempDir, yarnLockFile, yarnLockContent)

	source := artifact.Source{
		Type:     artifact.SourceTypeFilesystem,
		Location: tempDir,
	}

	ctx := context.Background()
	artifacts, err := analyzer.Scan(ctx, source)

	if err != nil {
		t.Errorf("Scan() error = %v", err)
		return
	}

	// Check if any NPM artifacts are found (depends on implementation)
	foundNpmArtifacts := false
	for _, art := range artifacts {
		if art.Type == artifact.TypeNpmPackage {
			foundNpmArtifacts = true
			break
		}
	}

	// Note: Not all implementations may parse yarn.lock
	if !foundNpmArtifacts {
		t.Log("No NPM artifacts found from yarn.lock (may not be implemented)")
	}
}

func TestDependencyAnalyzerGoSum(t *testing.T) {
	analyzer := NewDependencyAnalyzer()
	tempDir := t.TempDir()

	createTestFileGeneric(t, tempDir, goSumFile, goSumContent)

	source := artifact.Source{
		Type:     artifact.SourceTypeFilesystem,
		Location: tempDir,
	}

	ctx := context.Background()
	artifacts, err := analyzer.Scan(ctx, source)

	if err != nil {
		t.Errorf("Scan() error = %v", err)
		return
	}

	// Check if any Go module artifacts are found (depends on implementation)
	foundGoArtifacts := false
	for _, art := range artifacts {
		if art.Type == artifact.TypeGoModule {
			foundGoArtifacts = true
			break
		}
	}

	// Note: Not all implementations may parse go.sum
	if !foundGoArtifacts {
		t.Log("No Go module artifacts found from go.sum (may not be implemented)")
	}
}

// Test Python Pipfile
func TestDependencyAnalyzerPipfile(t *testing.T) {
	analyzer := NewDependencyAnalyzer()
	tempDir := t.TempDir()

	createTestFileGeneric(t, tempDir, pipfileFile, pipfileContent)

	source := artifact.Source{
		Type:     artifact.SourceTypeFilesystem,
		Location: tempDir,
	}

	ctx := context.Background()
	artifacts, err := analyzer.Scan(ctx, source)

	if err != nil {
		t.Errorf("Scan() error = %v", err)
		return
	}

	// Check if any Python artifacts are found (depends on implementation)
	foundPythonArtifacts := false
	for _, art := range artifacts {
		if art.Type == artifact.TypePythonPackage {
			foundPythonArtifacts = true
			break
		}
	}

	// Note: Not all implementations may parse Pipfile
	if !foundPythonArtifacts {
		t.Log("No Python artifacts found from Pipfile (may not be implemented)")
	}
}

// Test Gemfile and Gemfile.lock
func TestDependencyAnalyzerGemfile(t *testing.T) {
	analyzer := NewDependencyAnalyzer()
	tempDir := t.TempDir()

	createTestFileGeneric(t, tempDir, gemfileFile, gemfileContent)

	source := artifact.Source{
		Type:     artifact.SourceTypeFilesystem,
		Location: tempDir,
	}

	ctx := context.Background()
	artifacts, err := analyzer.Scan(ctx, source)

	if err != nil {
		t.Errorf("Scan() error = %v", err)
		return
	}

	// Check if any Ruby gem artifacts are found (depends on implementation)
	foundRubyArtifacts := false
	for _, art := range artifacts {
		if art.Type == artifact.TypeRubyGem {
			foundRubyArtifacts = true
			break
		}
	}

	// Note: Not all implementations may parse Gemfile
	if !foundRubyArtifacts {
		t.Log("No Ruby gem artifacts found from Gemfile (may not be implemented)")
	}
}

func TestDependencyAnalyzerGemfileLock(t *testing.T) {
	analyzer := NewDependencyAnalyzer()
	tempDir := t.TempDir()

	createTestFileGeneric(t, tempDir, gemfileLockFile, gemfileLockContent)

	source := artifact.Source{
		Type:     artifact.SourceTypeFilesystem,
		Location: tempDir,
	}

	ctx := context.Background()
	artifacts, err := analyzer.Scan(ctx, source)

	if err != nil {
		t.Errorf("Scan() error = %v", err)
		return
	}

	// Check if any Ruby gem artifacts are found (depends on implementation)
	foundRubyArtifacts := false
	for _, art := range artifacts {
		if art.Type == artifact.TypeRubyGem {
			foundRubyArtifacts = true
			break
		}
	}

	// Note: Not all implementations may parse Gemfile.lock
	if !foundRubyArtifacts {
		t.Log("No Ruby gem artifacts found from Gemfile.lock (may not be implemented)")
	}
}

// Test .NET packages.config and pubspec.lock
func TestDependencyAnalyzerPackagesConfig(t *testing.T) {
	analyzer := NewDependencyAnalyzer()
	tempDir := t.TempDir()

	createTestFileGeneric(t, tempDir, packagesConfigFile, packagesConfigContent)

	source := artifact.Source{
		Type:     artifact.SourceTypeFilesystem,
		Location: tempDir,
	}

	ctx := context.Background()
	artifacts, err := analyzer.Scan(ctx, source)

	if err != nil {
		t.Errorf("Scan() error = %v", err)
		return
	}

	// Check if any .NET package artifacts are found (depends on implementation)
	foundDotNetArtifacts := false
	for _, art := range artifacts {
		if art.Type == artifact.TypeDotNetPackage {
			foundDotNetArtifacts = true
			break
		}
	}

	// Note: Not all implementations may parse packages.config
	if !foundDotNetArtifacts {
		t.Log("No .NET package artifacts found from packages.config (may not be implemented)")
	}
}

func TestDependencyAnalyzerPubspecLock(t *testing.T) {
	analyzer := NewDependencyAnalyzer()
	tempDir := t.TempDir()

	createTestFileGeneric(t, tempDir, pubspecLockFile, pubspecLockContent)

	source := artifact.Source{
		Type:     artifact.SourceTypeFilesystem,
		Location: tempDir,
	}

	ctx := context.Background()
	artifacts, err := analyzer.Scan(ctx, source)

	if err != nil {
		t.Errorf("Scan() error = %v", err)
		return
	}

	// Check if any Dart package artifacts are found (depends on implementation)
	foundDartArtifacts := false
	for _, art := range artifacts {
		if art.Type == artifact.TypeDartPackage {
			foundDartArtifacts = true
			break
		}
	}

	// Note: Not all implementations may parse pubspec.lock
	if !foundDartArtifacts {
		t.Log("No Dart package artifacts found from pubspec.lock (may not be implemented)")
	}
}

// Test Conan files
func TestDependencyAnalyzerConanfileTxt(t *testing.T) {
	analyzer := NewDependencyAnalyzer()
	tempDir := t.TempDir()

	createTestFileGeneric(t, tempDir, conanfileTxtFile, conanfileTxtContent)

	source := artifact.Source{
		Type:     artifact.SourceTypeFilesystem,
		Location: tempDir,
	}

	ctx := context.Background()
	artifacts, err := analyzer.Scan(ctx, source)

	if err != nil {
		t.Errorf("Scan() error = %v", err)
		return
	}

	// Check if any Conan package artifacts are found (depends on implementation)
	foundConanArtifacts := false
	for _, art := range artifacts {
		if art.Type == artifact.TypeConanPackage {
			foundConanArtifacts = true
			break
		}
	}

	// Note: Not all implementations may parse conanfile.txt
	if !foundConanArtifacts {
		t.Log("No Conan package artifacts found from conanfile.txt (may not be implemented)")
	}
}

func TestDependencyAnalyzerConanfilePy(t *testing.T) {
	analyzer := NewDependencyAnalyzer()
	tempDir := t.TempDir()

	createTestFileGeneric(t, tempDir, conanfilePyFile, conanfilePyContent)

	source := artifact.Source{
		Type:     artifact.SourceTypeFilesystem,
		Location: tempDir,
	}

	ctx := context.Background()
	artifacts, err := analyzer.Scan(ctx, source)

	if err != nil {
		t.Errorf("Scan() error = %v", err)
		return
	}

	// Check if any Conan package artifacts are found (depends on implementation)
	foundConanArtifacts := false
	for _, art := range artifacts {
		if art.Type == artifact.TypeConanPackage {
			foundConanArtifacts = true
			break
		}
	}

	// Note: Not all implementations may parse conanfile.py
	if !foundConanArtifacts {
		t.Log("No Conan package artifacts found from conanfile.py (may not be implemented)")
	}
}

// Test additional package managers
func TestDependencyAnalyzerMixExs(t *testing.T) {
	analyzer := NewDependencyAnalyzer()
	tempDir := t.TempDir()

	createTestFileGeneric(t, tempDir, mixExsFile, mixExsContent)

	source := artifact.Source{
		Type:     artifact.SourceTypeFilesystem,
		Location: tempDir,
	}

	ctx := context.Background()
	artifacts, err := analyzer.Scan(ctx, source)

	if err != nil {
		t.Errorf("Scan() error = %v", err)
		return
	}

	// Check if any Hex package artifacts are found (depends on implementation)
	foundHexArtifacts := false
	for _, art := range artifacts {
		if art.Type == artifact.TypeHexPackage {
			foundHexArtifacts = true
			break
		}
	}

	// Note: Not all implementations may parse mix.exs
	if !foundHexArtifacts {
		t.Log("No Hex package artifacts found from mix.exs (may not be implemented)")
	}
}

func TestDependencyAnalyzerStackYaml(t *testing.T) {
	analyzer := NewDependencyAnalyzer()
	tempDir := t.TempDir()

	createTestFileGeneric(t, tempDir, stackYamlFile, stackYamlContent)

	source := artifact.Source{
		Type:     artifact.SourceTypeFilesystem,
		Location: tempDir,
	}

	ctx := context.Background()
	artifacts, err := analyzer.Scan(ctx, source)

	if err != nil {
		t.Errorf("Scan() error = %v", err)
		return
	}

	// Check if any Haskell package artifacts are found (depends on implementation)
	foundHaskellArtifacts := false
	for _, art := range artifacts {
		if art.Type == artifact.TypeHaskellPackage {
			foundHaskellArtifacts = true
			break
		}
	}

	// Note: Not all implementations may parse stack.yaml
	if !foundHaskellArtifacts {
		t.Log("No Haskell package artifacts found from stack.yaml (may not be implemented)")
	}
}

func TestDependencyAnalyzerTerraform(t *testing.T) {
	analyzer := NewDependencyAnalyzer()
	tempDir := t.TempDir()

	createTestFileGeneric(t, tempDir, terraformFile, terraformContent)

	source := artifact.Source{
		Type:     artifact.SourceTypeFilesystem,
		Location: tempDir,
	}

	ctx := context.Background()
	artifacts, err := analyzer.Scan(ctx, source)

	if err != nil {
		t.Errorf("Scan() error = %v", err)
		return
	}

	// Check if any Terraform config artifacts are found (depends on implementation)
	foundTerraformArtifacts := false
	for _, art := range artifacts {
		if art.Type == artifact.TypeTerraformConfig {
			foundTerraformArtifacts = true
			break
		}
	}

	// Note: Not all implementations may parse Terraform files
	if !foundTerraformArtifacts {
		t.Log("No Terraform config artifacts found from main.tf (may not be implemented)")
	}
}

// Test nested directory structure
func TestDependencyAnalyzerNestedDirectories(t *testing.T) {
	analyzer := NewDependencyAnalyzer()
	tempDir := t.TempDir()

	// Create nested structure with different package files
	createTestFileGeneric(t, tempDir, "frontend/package.json", packageJsonContent)
	createTestFileGeneric(t, tempDir, "backend/Cargo.toml", cargoTomlContent)
	createTestFileGeneric(t, tempDir, "services/api/go.mod", goModContent)
	createTestFileGeneric(t, tempDir, "infrastructure/main.tf", terraformContent)

	source := artifact.Source{
		Type:     artifact.SourceTypeFilesystem,
		Location: tempDir,
	}

	ctx := context.Background()
	artifacts, err := analyzer.Scan(ctx, source)

	if err != nil {
		t.Errorf("Scan() error = %v", err)
		return
	}

	if len(artifacts) == 0 {
		t.Error("Expected artifacts to be found in nested directories, got none")
		return
	}

	// Check that we found dependencies from different package managers in nested dirs
	foundTypes := make(map[artifact.Type]bool)
	for _, art := range artifacts {
		foundTypes[art.Type] = true
	}

	expectedTypes := []artifact.Type{
		artifact.TypeNpmPackage,
		artifact.TypeRustCrate,
		artifact.TypeGoModule,
	}

	for _, expectedType := range expectedTypes {
		if !foundTypes[expectedType] {
			t.Errorf("Expected to find artifacts of type %v in nested directories", expectedType)
		}
	}
}

// Benchmark tests
func BenchmarkDependencyAnalyzerScan(b *testing.B) {
	analyzer := NewDependencyAnalyzer()
	tempDir := b.TempDir()

	// Create multiple dependency files
	createTestFileGeneric(b, tempDir, packageJsonFile, packageJsonContent)
	createTestFileGeneric(b, tempDir, cargoTomlFile, cargoTomlContent)
	createTestFileGeneric(b, tempDir, goModFile, goModContent)
	createTestFileGeneric(b, tempDir, pomXmlFile, pomXmlContent)
	createTestFileGeneric(b, tempDir, requirementsTxtFile, requirementsTxtContent)

	source := artifact.Source{
		Type:     artifact.SourceTypeFilesystem,
		Location: tempDir,
	}

	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		ctx := context.Background()
		_, err := analyzer.Scan(ctx, source)
		if err != nil {
			b.Errorf("Scan() error = %v", err)
		}
	}
}

func BenchmarkDependencyAnalyzerLargeProject(b *testing.B) {
	analyzer := NewDependencyAnalyzer()
	tempDir := b.TempDir()

	// Create a larger project structure
	for i := 0; i < 50; i++ {
		subdir := filepath.Join(tempDir, "module"+fmt.Sprintf("%d", i))
		os.MkdirAll(subdir, 0755)
		createTestFileGeneric(b, subdir, packageJsonFile, packageJsonContent)
		createTestFileGeneric(b, subdir, goModFile, goModContent)
	}

	source := artifact.Source{
		Type:     artifact.SourceTypeFilesystem,
		Location: tempDir,
	}

	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		ctx := context.Background()
		_, err := analyzer.Scan(ctx, source)
		if err != nil {
			b.Errorf("Scan() error = %v", err)
		}
	}
}
